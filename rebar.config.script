%% -*- mode: erlang -*-
%% -*- tab-width: 4;erlang-indent-level: 4;indent-tabs-mode: nil -*-
%% ex: ts=4 sw=4 ft=erlang et

%% rebar.config.script GENERATED BY concrete
%%
%% YOU SHOULDN'T NEED TO EDIT THIS FILE
%%
{concrete_rebar_script_version, 3}.

%% We need the following helper function to merge dev only options
%% into the values provided by rebar.config.

%% Merge the list values in `ToAdd' into the list found at key `Key'
%% in proplist `C'. Don't duplicate items. New Items are added to the
%% front of existing items. It is an error if the value at `Key' is
%% not a list in `C'.
MergeConfig = fun(skip, C) ->
                      C;
                 ({Key, ToAdd}, C) ->
                      case lists:keyfind(Key, 1, C) of
                          false ->
                              lists:keystore(Key, 1, C, {Key, ToAdd});
                          {Key, List} when is_list(List) ->
                              %% remove items in ToAdd already in List
                              ToAdd1 = [ I || I <- ToAdd, not lists:member(I, List) ],
                              lists:keystore(Key, 1, C, {Key, List ++ ToAdd1 })
                      end
              end,

%% -- Add development only options if we are a top-level build  --
%%
%% If a file named `.concrete/DEV_MODE' exists, we assume we are a
%% top-level build (not being built as a dep of another project). We
%% add the deps from dev_only_deps defined in rebar.config, add
%% concrete as a dep, and define the compiler macro DEV_ONLY.

%% This macro can be used to conditionally enable code (e.g. tests)
%% that depend on development only dependencies.
ErlOpts = {erl_opts, [{d, 'DEV_ONLY'}]},

%% Development only dependencies can be specified in the main
%% rebar.config. This file should not need to be edited directly.
DevOnlyDeps = case lists:keyfind(dev_only_deps, 1, CONFIG) of
                  false ->
                      skip;
                  {dev_only_deps, DOD} ->
                      {deps, DOD}
              end,

EDown = case proplists:get_value(use_edown, CONFIG) of
               false ->
                   skip;
               _ ->
                DocOpts = case lists:keymember(edoc_opts, 1, CONFIG) of
                              true ->
                                  skip;
                              false ->
                                  {edoc_opts, [{doclet, edown_doclet}]}
                          end,
                [DocOpts,
                 {deps,
                  [{edown, ".*",
                    {git, "git://github.com/uwiger/edown.git",
                     {branch, "master"}}}]}]
           end,

LockDeps = case proplists:get_value(use_lock_deps, CONFIG) of
               false ->
                   skip;
               V ->
                   Tag = case V of
                             {_, _} = T -> T;
                             _ -> {branch, "master"}
                         end,
                   [{deps,
                     [{rebar_lock_deps_plugin, ".*",
                       {git, "git://github.com/seth/rebar_lock_deps_plugin.git",
                        Tag}}]},
                    {plugins, [rebar_lock_deps_plugin]}]
           end,

ConfigPath = filename:dirname(SCRIPT),
DevMarker = filename:join([ConfigPath, ".concrete/DEV_MODE"]),

case filelib:is_file(DevMarker) of
    true ->
        ToMerge = lists:flatten([DevOnlyDeps, LockDeps, EDown, ErlOpts]),
        lists:foldl(fun(I, C) -> MergeConfig(I, C) end,
                    CONFIG, ToMerge);
    false ->
        %% If the .concrete/ marker is not present, this script simply
        %% returns the config specified in rebar.config. This will be
        %% the behavior when the project is built as a dependency of
        %% another project.
        CONFIG
end.
